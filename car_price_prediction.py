# -*- coding: utf-8 -*-
"""Car_price_prediction.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YEzS5xeSc4TY5XB2NWbdPEQRUjVsgd13
"""

#import all the important libraries required for developing the model.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import tensorflow as tf
from sklearn.preprocessing import OneHotEncoder
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
import tensorflow as tf

#reading the dataset with the help of pandas library.
car = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/CarPrice_Assignment.csv')

#displaying first five rows of the dataframe using the head command
car.head(5)

#Other information of the dataset
car.info()

#description of the dataset
car.describe()

#pairplot of the dataset
sns.pairplot(data = car)

#replacing the string value by numeric value
car['doornumber'].replace({'two':2,'four':4},inplace = True)

#total columns in the dataset
car.columns

#features selected as the predictors
selected_features = ['doornumber','wheelbase',
       'carlength', 'carwidth', 'carheight',
       'enginesize','stroke','boreratio',
       'compressionratio', 'horsepower', 'peakrpm', 'citympg', 'highwaympg']

#taking X as predictor variable
X = car[selected_features]

#taking y as target variable
y = car[['price']]

car['doornumber']

X

#normalization using MinMaxScaler
scaler = MinMaxScaler()
X_scaled = scaler.fit_transform(X)
y_scaled = scaler.fit_transform(y)

#shape of scaled values
print(X_scaled.shape)
print(y_scaled.shape)

#splitting the dataset into train and test
X_train, X_test, y_train, y_test = train_test_split(X_scaled,y_scaled,test_size = 0.33)

#shape of training and testing dataset
print(X_train.shape)
print(X_test.shape)
print(y_train.shape)
print(y_test.shape)

#fitting of training values into the model and calculation of training and testing accuracy of the model.
model1 = LinearRegression()
model1.fit(X_train,y_train)
print("Training Score",model1.score(X_test,y_test)*100)
print("Testing Score",model1.score(X_test,y_test)*100)

#Artificial Neural Network model
predictor_model = tf.keras.models.Sequential()
predictor_model.add(tf.keras.layers.Dense(units = 100, activation = 'relu', input_shape = (13,)))
predictor_model.add(tf.keras.layers.Dense(units = 100, activation = 'relu'))
predictor_model.add(tf.keras.layers.Dense(units = 100, activation = 'relu'))
predictor_model.add(tf.keras.layers.Dense(units = 1, activation = 'linear'))

#Summary of the ANN model
predictor_model.summary()

#Compiling the Ann model
predictor_model.compile(optimizer = 'Adam', loss = 'mean_squared_error')

#Calculating the epochs of the model
epochs_hist = predictor_model.fit(X_scaled,y_scaled,epochs = 50, validation_split = 0.33,batch_size = 125)

#Finding the keys of the model
epochs_hist.history.keys()

#Constructing the loss and validation loss vs epochs graphs of the model
eh = epochs_hist.history['loss']
eh2 = epochs_hist.history['val_loss']
plt.plot(eh)
plt.plot(eh2)
plt.title('loss and validation loss graph')
plt.xlabel('epochs')
plt.ylabel('loss and validation loss')

#Model predicting the values
y_predict = predictor_model.predict(X_test)

#Predicted values
y_predict

#graph between y_test and y_predict.
plt.plot(y_test,y_predict, '^', color = 'r')
plt.xlabel('y_test')
plt.ylabel('y_predict')

#graph between y_test_original and y_predict_original.
y_predict_original = scaler.inverse_transform(y_predict)
y_test_original = scaler.inverse_transform(y_test)
plt.plot(y_test_original,y_predict_original,'^',color = 'b')
plt.xlabel('model_predictions')
plt.ylabel('true_values')

#calculating the value of n
k = X_test.shape
k
n = len(X_test)
print('value of n:',n)

#calculation of Root Mean Squared Error
from sklearn.metrics import r2_score,mean_squared_error,mean_absolute_error
from math import sqrt
RMSE = float(format(np.sqrt(mean_squared_error(y_test_original,y_predict_original)), '0.3f'))
print("Root Mean Squared Error: ",RMSE)

#calculation of Mean Squared Error
MSE = mean_squared_error(y_test_original,y_predict_original)
print("MeanSquared Error: ",MSE)

#calculation of R2 score
MAE = mean_absolute_error(y_test_original,y_predict_original)
print(MAE)
r2 = r2_score(y_test_original,y_predict_original)
print("r2 Score of the model is: ",r2)

